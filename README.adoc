= Rust Client for Baserow
This repository contains a client to interact with Baserow from Rust.

The code is split into two crates: `baserow-codegen` and `baserow-client`.

*baserow-codegen* is a binary crate that can be used to generate structs and enums that represent your
tables in Baserow.
The generator will need a database token that has access to your baserow tables, use this to obtain the structure of your tables and generate structs and enums to match this structure.

*baserow-client* is the actual client, which can then be used to interact with data in your Baserow tables.
It uses the structs generated by codegen to represent data.

== Installation
The code generator is intended to be used as a cargo plugin and can be installed with:
`cargo install --git https://github.com/soenkeliebau/baserow-codegen.git baserow-codegen`

== Supported Column Types


|===
|Baserow |Rust |Comments

|Single line text
|Option<String>
|

|Long text
|Option<String>
|

|Link to table
| Unsupported
|

|Number
|Option<usize>
Option<isize>
Option<f64>
|The concrete implementation is chosen based on the configuration of the field, most notably, whether the number has decimal places and can be negative.

|Rating
|Unsupported
|

|Boolean
|Option<bool>
|

|Date
|Option<DateTime<Local>>
|

|Last modified
|Option<String>
|

|Created on
|Option<String>
|

|URL
|Option<String>
|

|Email
|Option<String>
|

|File
|
|

|Single select
|Option<Enum>
|An enum is generated with the name `<Tablename><Fieldname>` and a variant per possible value of the select field is added.

|Multiple select
|Option<Vec<Enum>>
|An enum is generated with the name `<Tablename><Fieldname>` and a variant per possible value of the select field is added.

|Phone number
|Option<Enum>
|

|Formula
|Unsupported
|

|Lookup
|Unsupported
|

|Collaborator
|Option<String>
|

|Count
|Option<usize>
|

|Rollup
|Unsupported
|

|Created by
|Unsupported
|

|Last modified by
|Unsupported
|

|Duration
|
|

|Autonumber
|Option<usize>
|

|UUID
|Option<String>
|

|Last modified
|Option<String>
|

|Created on
|
|

|Password
|
|

|AI
|
|

|===


== Baserow Idiosyncracies
Baserow has made a few design choices that make it behave fundamentally different to a database - this results in some trickle-down design choices I had to make for these crates which I would have liked to implement differently.
This section gives a rough overview of these decisions and will hopefully explain a few things you might wonder about while using the crates.

=== Cells vs Rows
Baserow doesn't really treat table rows as rows, but rather as individual fields that are grouped together (if that makes sense).
What this means in practice is, that you don't enter all data for a row and then insert the row, but rather insert an empty row and then start filling in the fields.
Which in turn means there cannot be any mandatory fields, because of that empty row thing -> all fields can always be null.
What this means for us in Rust is: regardless of the type of a field in Baserow, in Rust it is always an `Option<...>`.

=== Primary Field doesn't have to be unique
Baserow tables have a primary field, which according to the documentation should be a unique name identifying a row in the table - Spoiler alert: its not! Baserow doesn't enforce uniqueness for the primary field, the actual primary key for every table is the hard coded `id` field in that table.

Because that `id` is pretty much an implementation detail that shouldn't bleed through into higher level abstractions it is not exposed (for now) by baserow-client.
Instead the client does its best to translate values from the primary field to the underlying ids of your rows by querying for value of the primary key field and retrieving the id for that row.
This won't work if you have rows with the same primary field value in your data - for those cases the client will refuse to update any row, because it cannot tell which one would be the correct one.

=== Everything is a string
Since Baserow exposes a REST api to interact with it, all data needs to be represented as json, so fields can either be a number or a string.
However in the case of Baserow a decision was made to also send numeric fields as Strings, which is annoying, since in Rust we obviously want to use numbers to work with the data.
To work around this limitation the code generator adds annotations to the structs to instruct serde, which fields should be deserialized as numbers.
Works fine in principle, but may break in interesting ways that I have not found in testing, so I figured its worth mentioning here.